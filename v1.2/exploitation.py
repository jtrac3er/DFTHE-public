"""
Hier kommen so die Versuche rein, die Krypto zu brechen

"""

from complex import *
from crypt import *
from lgs import *
from random import randint
from math import gcd


key = keygen(3, min_rand=1e100, max_rand=9e100)
Complex.N = key.N
n = key.n


"""
# 1. Also erstens mal versuchen, das inverse zu berechnen

message = 0
checksum = 1

c = encrypt(key, message, s=checksum)

A = convolve_matrix(c)
b = [CUnit] + [CZero for i in range(n-1)]

pp_mat(A)
print()
pp_vec(b)
print()


try:
	x = gauss_elimination(A, b)
except ZeroDivisionError as e:
	print(f"failed division wegen {e.inv} mit l={e.inv.l()}")

pp_vec(x)
assert(matrix_mul(A,x) == b)

d = decrypt(key, x, se=1)
print(d)
print(d * message % key.N)
#"""

"""
Also das geht super. Man kann das Inverse locker so berechnen und es stimmt auch überein
Zudem: Wenn immer es failt, dann hat der auslösende Vektor immer den Betrag 0, also wird
auch nichts über die PFZ geleakt

"""

"""
# 2. ein kleiner test noch um zu überprüfen, ob man wirklich überall 1 dazu rechnen kann 
v = [(randint(0,10), randint(0,10)) for i in range(key.n)]
c = encrypt_vector(key, v)

x = [CUnit for i in range(key.n)]
y = [CUnit] + [CZero for i in range(key.n)]

print(decrypt_vector(key, c))
print(decrypt_vector(key, hom_add(c, x)))
print(decrypt_vector(key, hom_add(c, y)))
#"""

"""
Auch hier wieder die erwarteten Resultate. Natürlich funktioniert das
"""

"""
# 3. Was passiert, wenn man alle Werte transponiert?
v = [(randint(0,10), randint(0,10)) for i in range(key.n)]
c = encrypt_vector(key, v)
t = [i.t() for i in c]

# mit der jetztigen Version ist das ein krasses Exploit, der behoben werden muss, denn
# wenn die DFT-Matrix nur Reelle Werte verwendet, dann kann man die PFZ berechnen
print(decrypt_vector(key, c))
print(decrypt_vector(key, t))

# also für den reellen case:
m = 10
c = encrypt(key, m, s=123)

a = hom_add( hom_smul(-m,c), hom_mul(c,c) )	# a hat den wert 0
one = [CUnit] + [CZero for i in range(key.n)]
at = [i.t() for i in a]
a2 = hom_mul(a, at)
ao = hom_add(a2, one)						# a hat den wert 1

mat = [hom_pow(ao, i) for i in range(3)]
b = [CUnit for i in range(3)]
x = gauss_elimination(mat, b)

print("\nDecryption of ao")
print(decrypt_vector(key, ao))
print("\nCalculated unity roots")
pp_vec(x)
print("\nUnity root from key.u")
print(key.u)
#"""

"""
Also der Exploit funktioniert immer dann, wenn die DFT matrix reell ist
Noch schlimmer: Der Exploit funktioniert auch, wenn die DFT-Matrix nicht reell ist sondern komplex
Also das breakt gerade so alles, was ich im Kopf hatte. Aber macht sinn

Das Problem ist, auch wenn die DFT matrix komplexe Werte hat, auch dann, wenn man sie transponiert, dann
resultiert das lediglich in einer Verschiebung im Plaintext, also

0 0 
a b
c d

wird dann einfach zu

0 0 
d c
b a

Also man swappt die Spalten und verschiebt die Reihen um einen bestimmten Wert. Das ist ein Problem, 
vorallem wenn man n=3 verwendet, dann was dann passiert ist

0 0			0 0
0 r   und	c r
r c 		r 0

Wenn man diese dann multipliziert, dann erhält man (k=r*r) und beides mal derselbe Wert

0    0
0    k
k    0

Und das ist dann ein Problem. 

Der Exploit funktioniert in abgewandelter Art leider immer, also das Schema ist unsicher des Todes.
Wieder mal ein Beweis dafür, dass Modulare Arithmetik und Linearität kein FHE erzeugen...

SCHEME BUSTED

"""

